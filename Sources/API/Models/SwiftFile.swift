//
//  SwiftFile.swift
//  
//
//  Created by Nickolay Truhin on 28.11.2020.
//

import Foundation

protocol SwiftFile {
    var params: [RespParameter] { get }
    var description: String { get }
    var string: String { get }
}

extension SwiftFile {
    var wrappedString: String {
        """
        // Vkontakter - VK Bot Swift SDK.
        // This file is autogenerated by API package.

        \(string)
        """
    }
    
}

struct TypeFile: SwiftFile {
    let description: String
    let params: [RespParameter]
    let apiName: String
    
    var codeName: String {
        apiName.capitalizingFirstLetter()
    }
    
    var string: String {
        """
        /**
         \(description)

         SeeAlso VK API Reference:
         [\(codeName)](https://vk.com/dev/objects/\(apiName)
         */
        public final class \(codeName): Codable {
            \(params.objectsContent.i(1))
            \(params.enumsContent.i(1))
            \(params.generate.i(1))
            \(params.generateInit().i(1))
        }
        """
    }
}

struct MethodExtensionFile: SwiftFile {
    let description: String
    let params: [RespParameter]
    let methodGroup: String
    let method: Method
    let respParams: [RespParameter] // if empty then Flag

    var methodCodeCapitalized: String {
        method.codeName.capitalizingFirstLetter()
    }
    
    var methodApi: String {
        methodGroup + "." + method.apiName
    }
    
    var respType: String {
        respParams.isEmpty ? "VkFlag" : methodCodeCapitalized.capitalizingFirstLetter() + "Resp"
    }
    
    var respTypeContent: String {
        respParams.isEmpty ? "" : "\nstruct \(respType): Codable {\n\("\n".i(1))\(respParams.generate.i(1))\n}\n".i(1)
    }
    
    var paramsType: String {
        methodCodeCapitalized.capitalizingFirstLetter() + "Params"
    }

    var string: String {
        """
        public extension Bot {

            /// Parameters container struct for `\(method.codeName)` method
            struct \(paramsType): JSONEncodable {
                \(params.objectsContent.i(2))
                \(params.enumsContent.i(2))
                \(params.generate.i(2))
                \(params.generateInit().i(2))
            }
            \(respTypeContent)
            /**
             \(description)

             See also VK API Reference:
             [\(methodCodeCapitalized)](https://vk.com/dev/\(methodApi))
             
             - Parameters:
                 - params: Parameters container, see `\(paramsType)` struct
             - Throws: Throws on errors
             - Returns: Future of `\(respType)` type
             */
            @discardableResult
            func \(method.codeName)(params: \(paramsType)) throws -> Future<\(respType)> {
                let headers = httpHeaders(for: params)
                return try client
                    .request(endpoint: "\(methodApi)", params: params, headers: headers)
                    .flatMapThrowing { (container) -> \(respType) in
                        return try self.processContainer(container)
                }
            }
        }
        """
    }
}

extension Array where Element == RespParameter {
    private var initParams: String {
        String(map { param in "\(param.name): \(param.typeString)\(param.required ? "" : " = nil"), " }.joined().dropLast(2))
    }
    
    private var initContent: String {
        map { param in "self.\(param.name) = \(param.name)" }.joined(separator: "\n")
    }
    
    func generateInit(_ publicInit: Bool = true) -> String {
        isEmpty ? "" : """
        \(publicInit ? "public " : "")init(\(initParams)) {
            \(initContent.i(1))
        }
        """
    }
    
    var generate: String {
        map { param in
            var str = "let \(param.name): \(param.typeString)\n\n"
            if let desc = param.description, !desc.isEmpty {
                str = "/// \(desc)\n" + str
            }
            return str
        }.joined()
    }
    
    var objects: [RespObject] {
        filter { resp in !RespParameter.ParamType.hardcodedCases.contains(resp.type) }
            .compactMap { param in
            if case let .Object(obj) = param.type, let object = obj {
                return object
            }
            return nil
        }
    }
    
    var objectsContent: String {
        let objects = self.objects
        guard !objects.isEmpty else { return "" }
        return "\n" + objects.map { object in
            "struct \(object.name): Codable {\((object.params.objectsContent + object.params.enumsContent).i(1))\n\("\n".i(1))\(object.params.generate.i(1))\(object.params.generateInit().i(1))\n}\n"
        }.joined(separator: "\n")
    }
    
    var enums: [RespEnum] {
        filter { resp in !RespParameter.ParamType.hardcodedCases.contains(resp.type) }
            .compactMap { param in
            if case let .Enum(en) = param.type, let _enum = en {
                return _enum
            }
            return nil
        }
    }

    var enumsContent: String {
        let enums = self.enums
        guard !enums.isEmpty else { return "" }
        return "\n" + enums.map { _enum in
            let casesContent: String = _enum.cases.map {
                let valueStr: String
                switch _enum.casesType {
                case .String:
                    valueStr = "\"\($0.value)\""
                default:
                    valueStr = String(describing: $0.value)
                }
                return "\ncase \($0.key) = \(valueStr)".i(1)
            }.joined()
            return "enum \(_enum.name): \(_enum.casesType.string), Codable {\(casesContent)\n}\n"
        }.joined(separator: "\n")
    }
}
