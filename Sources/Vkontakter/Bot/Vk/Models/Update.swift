// Telegrammer - Telegram Bot Swift SDK.
// This file is autogenerated by API/generate_wrappers.rb script.
/**
 Событие представляет собой JSON, имеющий следующую структуру:
 {"type": <тип события>, "object": <объект, инициировавший событие>, "group_id": <ID сообщества, в котором произошло событие>}
 Например:
 {"type": "group_join", "object": {"user_id": 1, "join_type" : "approved"}, "group_id": 1}
 Структура объекта в поле object зависит от типа уведомления.
 SeeAlso VK Bot API Reference:
 [Update](https://vk.com/dev/groups_events)
 */
public final class Update: Codable {

    public enum `Type`: String, Codable {
        case message_new
        case message_event
        case confirmation
    }
    
    public let type: Type

    public let secret: String?
    
    public enum Object: Codable {
        case message(_ wrapper: MessageWrapper)
        case event(_ event: MessageEvent)
        
        public struct MessageWrapper: Codable {
            public let message: Message
            
            public init(_ message: Message) {
                self.message = message
            }
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            
            if let messageWrapper = try? MessageWrapper(from: decoder) {
                self = .message(messageWrapper)
            } else if let messageEvent = try? MessageEvent(from: decoder) {
                self = .event(messageEvent)
            } else {
                throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: container.codingPath, debugDescription: "Data doesn't match"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            switch self {
            case let .message(messageWrapper):
                try messageWrapper.encode(to: encoder)
            case let .event(event):
                try event.encode(to: encoder)
            }
        }
    }

    public let object: Object?
    
    public init(type: Type, secretKey: String, object: Object) {
        self.type = type
        self.secret = secretKey
        self.object = object
    }
    
    private enum CodingKeys: CodingKey {
        case type, secret, object
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        self.type = try container.decode(Type.self, forKey: .type)
        
        switch type {
        case .message_new:
            object = .message(try container.decode(Object.MessageWrapper.self, forKey: .object))
        case .message_event:
            object = .event(try container.decode(MessageEvent.self, forKey: .object))
        case .confirmation:
            object = nil
        }
        
        self.secret = try container.decode(String.self, forKey: .secret)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(type, forKey: .type)
        try container.encode(secret, forKey: .secret)

        switch object {
        case let .message(message):
            try container.encode(message, forKey: .object)
        case let .event(event):
            try container.encode(event, forKey: .object)
        case .none:
            try container.encodeNil(forKey: .object)
        }
    }
}
