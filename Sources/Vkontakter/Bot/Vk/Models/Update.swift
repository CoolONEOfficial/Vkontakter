// Telegrammer - Telegram Bot Swift SDK.
// This file is autogenerated by API/generate_wrappers.rb script.
/**
 Событие представляет собой JSON, имеющий следующую структуру:
 {"type": <тип события>, "object": <объект, инициировавший событие>, "group_id": <ID сообщества, в котором произошло событие>}
 Например:
 {"type": "group_join", "object": {"user_id": 1, "join_type" : "approved"}, "group_id": 1}
 Структура объекта в поле object зависит от типа уведомления.
 SeeAlso VK Bot API Reference:
 [Update](https://vk.com/dev/groups_events)
 */
public final class Update: Codable {

    public enum `Type`: String, Codable {
        case message_new
        case message_edit
        case message_reply
        case message_event
        case confirmation
    }
    
    public let type: Type

    public let secret: String?
    
    public enum Object {
        case messageWrapper(_ wrapper: MessageWrapper)
        case message(_ message: Message)
        case event(_ event: MessageEvent)
        
        public struct MessageWrapper: Codable {
            public let message: Message
            
            public init(_ message: Message) {
                self.message = message
            }
        }
        
        var message: Message? {
            switch self {
            case let .message(message):
                return message
            case let .messageWrapper(wrapper):
                return wrapper.message
            default:
                return nil
            }
        }
    }

    public let object: Object?
    
    public init(type: Type, secretKey: String, object: Object) {
        self.type = type
        self.secret = secretKey
        self.object = object
    }
    
    private enum CodingKeys: CodingKey {
        case type, secret, object
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        self.type = try container.decode(Type.self, forKey: .type)
        
        switch type {
        case .message_new:
            object = .messageWrapper(try container.decode(Object.MessageWrapper.self, forKey: .object))
        case .message_edit, .message_reply:
            object = .message(try container.decode(Message.self, forKey: .object))
        case .message_event:
            object = .event(try container.decode(MessageEvent.self, forKey: .object))
        case .confirmation:
            object = nil
        }
        
        self.secret = try container.decode(String.self, forKey: .secret)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(type, forKey: .type)
        try container.encode(secret, forKey: .secret)

        switch object {
        case let .message(message):
            try container.encode(message, forKey: .object)
        case let .event(event):
            try container.encode(event, forKey: .object)
        case let .messageWrapper(messageWrapper):
            try container.encode(messageWrapper, forKey: .object)
        case .none:
            try container.encodeNil(forKey: .object)
        }
    }
}
