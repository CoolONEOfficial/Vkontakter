// Vkontakter - VK Bot Swift SDK.
// This file is autogenerated by API package.

import AnyCodable

public extension Bot {

    /// Parameters container struct for `sendMessage` method
    final class SendMessageParams: JSONEncodable {

        /// Идентификатор пользователя, которому отправляется сообщение.
        public let userId: Int64?
        
        /// Число в пределах int32 - уникальный (в привязке к API_ID и ID отправителя) идентификатор, предназначенный для предотвращения повторной отправки одинакового сообщения. Сохраняется вместе с сообщением и доступен в истории сообщений. Переданный в запросе random_id используется для проверки уникальности, проверяя в заданном диалоге сообщения за последний час (но не более 100 последних сообщений). целое число, доступен начиная с версии 5.
        public let randomId: Int32?
        
        /// Идентификатор назначения. Для пользователя: id пользователя. Для групповой беседы: 2000000000 + id беседы. Для сообщества: -id сообщества. целое число, доступен начиная с версии 5.
        public let peerId: Int64?
        
        /// Идентификаторы получателей сообщения (при необходимости отправить сообщение сразу нескольким пользователям). Доступно только для ключа доступа сообщества. Максимальное количество идентификаторов: 100. список целых чисел, разделенных запятыми, доступен начиная с версии 5.
        public let peerIds: [Int64]?
        
        /// Короткий адрес пользователя (например, illarionov).
        public let domain: String?
        
        /// Идентификатор беседы, к которой будет относиться сообщение.
        public let chatId: UInt64?
        
        /// Текст личного сообщения. Обязательный параметр, если не задан параметр attachment.
        public let message: String?
        
        /// Географическая широта (от -90 до 90).
        public let lat: Double?
        
        /// Географическая долгота (от -180 до 180).
        public let long: Double?
        
        /// Медиавложения к личному сообщению, перечисленные через запятую. Каждое прикрепление представлено в формате: <type><owner_id>_<media_id> <type> — тип медиавложения: photo — фотография; video — видеозапись; audio — аудиозапись; doc — документ; wall — запись на стене; market — товар. poll — опрос. <owner_id> — идентификатор владельца медиавложения (обратите внимание, если объект находится в сообществе, этот параметр должен быть отрицательным). <media_id> — идентификатор медиавложения. Например: photo100172_166443618 Параметр является обязательным, если не задан параметр message.
        public let attachment: Attachments?
        
        /// Идентификатор сообщения, на которое требуется ответить. целое число, доступен начиная с версии 5.
        public let replyTo: Int64?
        
        /// Идентификаторы пересылаемых сообщений, перечисленные через запятую. Перечисленные сообщения отправителя будут отображаться в теле письма у получателя.
        public let forwardMessages: [Int64]?
        
        /// JSON-объект со следующими полями: owner_id — владелец сообщений. Стоит передавать, если вы хотите переслать сообщения из сообщества в диалог; peer_id — идентификатор места, из которого необходимо переслать сообщения; conversation_message_ids — массив conversation_message_id сообщений, которые необходимо переслать. В массив conversation_message_ids можно передать сообщения: находящиеся в личном диалоге с ботом; являющиеся исходящими сообщениями бота; написанными после того, как бот вступил в беседу и появился доступ к сообщениям. message_ids — массив id сообщений; is_reply — ответ на сообщения. Стоит передавать, если вы хотите ответить на сообщения в том чате, в котором находятся сообщения. При этом в conversation_message_ids/message_ids должен находиться только один элемент.
        public final class Forward: Codable {
            
            
            public init() {
            }
        }
        
        public let forward: [Forward]?
        
        /// Идентификатор стикера.
        public let stickerId: UInt64?
        
        /// Идентификатор сообщества (для сообщений сообщества с ключом доступа пользователя).
        public let groupId: UInt64?
        
        /// Объект, описывающий клавиатуру бота.
        public let keyboard: Keyboard?
        
        /// Объект, описывающий шаблон сообщения.
        public let template: Template?
        
        /// Полезная нагрузка.
        public let payload: Message.Payload?
        
        /// Объект, описывающий источник пользовательского контента для чат-ботов.
        public let contentSource: ContentSource?
        
        /// 1 — не создавать сниппет ссылки из сообщения.
        public let dontParseLinks: VkFlag?
        
        /// 1 - отключить уведомление об упоминании в сообщении.
        public let disableMentions: VkFlag?
        
        /// Строка, описывающая интенты.
        public let intent: String?
        
        /// Число, которое в будущем будет предназначено для работы с интентами.
        public let subscribeId: UInt64?
        
        public init(userId: Int64? = nil, randomId: Int32? = nil, peerId: Int64? = nil, peerIds: [Int64]? = nil, domain: String? = nil, chatId: UInt64? = nil, message: String? = nil, lat: Double? = nil, long: Double? = nil, attachment: Attachments? = nil, replyTo: Int64? = nil, forwardMessages: [Int64]? = nil, forward: [Forward]? = nil, stickerId: UInt64? = nil, groupId: UInt64? = nil, keyboard: Keyboard? = nil, template: Template? = nil, payload: Message.Payload? = nil, contentSource: ContentSource? = nil, dontParseLinks: VkFlag? = nil, disableMentions: VkFlag? = nil, intent: String? = nil, subscribeId: UInt64? = nil) {
            self.userId = userId
            self.randomId = randomId
            self.peerId = peerId
            self.peerIds = peerIds
            self.domain = domain
            self.chatId = chatId
            self.message = message
            self.lat = lat
            self.long = long
            self.attachment = attachment
            self.replyTo = replyTo
            self.forwardMessages = forwardMessages
            self.forward = forward
            self.stickerId = stickerId
            self.groupId = groupId
            self.keyboard = keyboard
            self.template = template
            self.payload = payload
            self.contentSource = contentSource
            self.dontParseLinks = dontParseLinks
            self.disableMentions = disableMentions
            self.intent = intent
            self.subscribeId = subscribeId
        }
    
    }
    
    final class SendMessageResp: Codable {
    
        public final class Item: Codable {
            
            /// Идентификатор назначения.
            public let peerId: Int64?
            
            /// Идентификатор сообщения.
            public let messageId: Int64?
            
            /// Идентификатор сообщения в диалоге.
            public let conversationMessageId: Int64?
            
            /// Сообщение об ошибке, если сообщение не было доставлено получателю.
            public let error: String?
            
            public init(peerId: Int64? = nil, messageId: Int64? = nil, conversationMessageId: Int64? = nil, error: String? = nil) {
                self.peerId = peerId
                self.messageId = messageId
                self.conversationMessageId = conversationMessageId
                self.error = error
            }
        }
        
        public let items: [Item]
        
        public init(items: [Item]) {
            self.items = items
        }
    
    }
    
    /**
     Отправляет сообщение.
     После успешного выполнения возвращает идентификатор отправленного сообщения.

     See also VK API Reference:
     [SendMessage](https://vk.com/dev/messages.send)
     
     - Parameters:
         - params: Parameters container, see `SendMessageParams` struct
     - Throws: Throws on errors
     - Returns: Future of `SendMessageResp` type
     */
    @discardableResult
    func sendMessage(params: SendMessageParams) throws -> Future<SendMessageResp> {
        let headers = httpHeaders(for: params)
        return try client
            .request(endpoint: "messages.send", params: params, headers: headers)
            .flatMapThrowing { (container) -> SendMessageResp in
                return try self.processContainer(container)
        }
    }
}