// Vkontakter - VK Bot Swift SDK.
// This file is autogenerated by API package.

public extension Bot {

    /// Parameters container struct for `sendMessage` method
    struct SendMessageParams: JSONEncodable {
        struct Forward: Codable {
        
            /// Владелец сообщений. Стоит передавать, если вы хотите переслать сообщения из сообщества в диалог.
            let ownerId: String?
            
            /// Идентификатор места, из которого необходимо переслать сообщения.
            let peerId: String?
            
            /// Массив conversation_message_id сообщений, которые необходимо переслать. В массив conversation_message_ids можно передать сообщения: находящиеся в личном диалоге с ботом. являющиеся исходящими сообщениями бота. написанными после того, как бот вступил в беседу и появился доступ к сообщениям.
            let conversationMessageIds: String?
            
            /// Массив id сообщений.
            let messageIds: String?
            
            /// Ответ на сообщения. Стоит передавать, если вы хотите ответить на сообщения в том чате, в котором находятся сообщения. При этом в conversation_message_ids/message_ids должен находиться только один элемент.
            let isReply: String?
            
            public init(ownerId: String? = nil, peerId: String? = nil, conversationMessageIds: String? = nil, messageIds: String? = nil, isReply: String? = nil) {
                self.ownerId = ownerId
                self.peerId = peerId
                self.conversationMessageIds = conversationMessageIds
                self.messageIds = messageIds
                self.isReply = isReply
            }
        }
        
        /// Идентификатор пользователя, которому отправляется сообщение.
        let userId: Int64?
        
        /// Уникальный (в привязке к API_ID и ID отправителя) идентификатор, предназначенный для предотвращения повторной отправки одинакового сообщения. Сохраняется вместе с сообщением и доступен в истории сообщений. Заданный random_id используется для проверки уникальности за всю историю сообщений, поэтому используйте большой диапазон (до int32). целое число, доступен начиная с версии 5.
        let randomId: Int64?
        
        /// Идентификатор назначения. Для пользователя: id пользователя. Для групповой беседы: 2000000000 + id беседы. Для сообщества: -id сообщества. целое число, доступен начиная с версии 5.
        let peerId: Int64?
        
        /// Идентификаторы получателей сообщения (при необходимости отправить сообщение сразу нескольким пользователям). Доступно только для ключа доступа сообщества. Максимальное количество идентификаторов: 100. список целых чисел, разделенных запятыми, доступен начиная с версии 5.
        let peerIds: [Int64]?
        
        /// Короткий адрес пользователя (например, illarionov).
        let domain: String?
        
        /// Идентификатор беседы, к которой будет относиться сообщение.
        let chatId: UInt64?
        
        /// Текст личного сообщения. Обязательный параметр, если не задан параметр attachment.
        let message: String
        
        /// Географическая широта (от -90 до 90).
        let lat: Double?
        
        /// Географическая долгота (от -180 до 180).
        let long: Double?
        
        /// Медиавложения к личному сообщению, перечисленные через запятую. Каждое прикрепление представлено в формате: <type><owner_id>_<media_id> <type> — тип медиавложения: photo — фотография; video — видеозапись; audio — аудиозапись; doc — документ; wall — запись на стене; market — товар. poll — опрос. <owner_id> — идентификатор владельца медиавложения (обратите внимание, если объект находится в сообществе, этот параметр должен быть отрицательным). <media_id> — идентификатор медиавложения. Например: photo100172_166443618 Параметр является обязательным, если не задан параметр message.
        let attachment: String?
        
        /// Идентификатор сообщения, на которое требуется ответить. целое число, доступен начиная с версии 5.
        let replyTo: Int64?
        
        /// Идентификаторы пересылаемых сообщений, перечисленные через запятую. Перечисленные сообщения отправителя будут отображаться в теле письма у получателя.
        let forwardMessages: [Int64]?
        
        /// JSON-объект со следующими полями: owner_id — владелец сообщений. Стоит передавать, если вы хотите переслать сообщения из сообщества в диалог; peer_id — идентификатор места, из которого необходимо переслать сообщения; conversation_message_ids — массив conversation_message_id сообщений, которые необходимо переслать. В массив conversation_message_ids можно передать сообщения: находящиеся в личном диалоге с ботом; являющиеся исходящими сообщениями бота; написанными после того, как бот вступил в беседу и появился доступ к сообщениям. message_ids — массив id сообщений; is_reply — ответ на сообщения. Стоит передавать, если вы хотите ответить на сообщения в том чате, в котором находятся сообщения. При этом в conversation_message_ids/message_ids должен находиться только один элемент.
        let forward: Forward?
        
        /// Идентификатор стикера.
        let stickerId: UInt64?
        
        /// Идентификатор сообщества (для сообщений сообщества с ключом доступа пользователя).
        let groupId: UInt64?
        
        /// Объект, описывающий клавиатуру бота.
        let keyboard: VkKeyboard?
        
        /// Объект, описывающий шаблон сообщения.
        let template: VkTemplate?
        
        /// Полезная нагрузка.
        let payload: String?
        
        /// Объект, описывающий источник пользовательского контента для чат-ботов.
        let contentSource: VkContentSource?
        
        /// 1 — не создавать сниппет ссылки из сообщения.
        let dontParseLinks: VkFlag?
        
        /// 1 - отключить уведомление об упоминании в сообщении.
        let disableMentions: VkFlag?
        
        /// Строка, описывающая интенты.
        let intent: String?
        
        /// Число, которое в будущем будет предназначено для работы с интентами.
        let subscribeId: UInt64?
        
        
        public init(userId: Int64? = nil, randomId: Int64? = nil, peerId: Int64? = nil, peerIds: [Int64]? = nil, domain: String? = nil, chatId: UInt64? = nil, message: String, lat: Double? = nil, long: Double? = nil, attachment: String? = nil, replyTo: Int64? = nil, forwardMessages: [Int64]? = nil, forward: Forward? = nil, stickerId: UInt64? = nil, groupId: UInt64? = nil, keyboard: VkKeyboard? = nil, template: VkTemplate? = nil, payload: String? = nil, contentSource: VkContentSource? = nil, dontParseLinks: VkFlag? = nil, disableMentions: VkFlag? = nil, intent: String? = nil, subscribeId: UInt64? = nil) {
            self.userId = userId
            self.randomId = randomId
            self.peerId = peerId
            self.peerIds = peerIds
            self.domain = domain
            self.chatId = chatId
            self.message = message
            self.lat = lat
            self.long = long
            self.attachment = attachment
            self.replyTo = replyTo
            self.forwardMessages = forwardMessages
            self.forward = forward
            self.stickerId = stickerId
            self.groupId = groupId
            self.keyboard = keyboard
            self.template = template
            self.payload = payload
            self.contentSource = contentSource
            self.dontParseLinks = dontParseLinks
            self.disableMentions = disableMentions
            self.intent = intent
            self.subscribeId = subscribeId
        }
    }
    
    struct SendMessageResp: Codable {
    
        /// Идентификатор назначения.
        let peerId: String?
        
        /// Идентификатор сообщения.
        let messageId: String?
        
        /// Идентификатор сообщения в диалоге.
        let conversationMessageId: String?
        
        /// Сообщение об ошибке, если сообщение не было доставлено получателю.
        let error: String?
        
        
    }
    
    /**
     Отправляет сообщение.
     После успешного выполнения возвращает идентификатор отправленного сообщения.

     See also VK API Reference:
     [SendMessage](https://vk.com/dev/messages.send)
     
     - Parameters:
         - params: Parameters container, see `SendMessageParams` struct
     - Throws: Throws on errors
     - Returns: Future of `SendMessageResp` type
     */
    @discardableResult
    func sendMessage(params: SendMessageParams) throws -> Future<SendMessageResp> {
        let headers = httpHeaders(for: params)
        return try client
            .request(endpoint: "messages.send", params: params, headers: headers)
            .flatMapThrowing { (container) -> SendMessageResp in
                return try self.processContainer(container)
        }
    }
}
